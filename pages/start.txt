====== はじめに ======
本プロジェクトのドキュメントは、[[http://www.dokuwiki.org/ja:syntax|DokuWiki Markup]]で記述していきます。

HTMLで記述された文書はタグで覆われ、テキストで読んだときの可読性が下がってしまい、かつ、作成する際にタグの対応について配慮する必要がありますが、Wiki Markup を使用すると文章の元のプレーンな状態を比較的損なわない状態でマークアップを追記できます。

本プロジェクトの構成を、ローカルなDokuWikiシステム上で表示するには、プロジェクトディレクトリ以下のreadme.txtを参照して下さい。

=== 参考ドキュメント ===
  - {{scm-1.pdf|Linuxセキュリティ RCS}}


====== gitとは ======
[[http://git-scm.com|{{ 01-git-scm.png?400}}]]
gitは、Linuxの開発者であるLinus氏によって開発された、Linuxカーネルの開発でも使用されているバージョン管理ソフトウェアです。

開発中のプロジェクトのファイルをローカル、またはネットワークを通じてバージョン管理する事が可能になります。gitはこれまで多くのプロジェクトで使用されてきた、CVSやSubversion等と異なり、中央のリポジトリが必須ではなく、ローカルファイルのみを使いローカルマシンで独立したバージョン管理が可能な仕組みを提供します。また、他のユーザーとリモートリポジトリーを通じて共同作業することも可能です。

Linux環境のみならず、MacOS, FreeBSD, Windows環境へ移植されています。


参考リンク
  * [[http://git-scm.com|git開発サイト]]
  * [[http://www.youtube.com/watch?v=4XpnKHJAok8| YouTube, Google Tech Talk: Linus Torvalds on git]]
  - 

Linuxを使用しているのであれば、ディストリビューションによって、RPMやdebのようなパッケージが用意されているかもしれません。

**Scientific Linux 6.1での例)**

<code>
# yum info git
...
Name        : git
Arch        : x86_64
Version     : 1.7.1
Release     : 2.el6_0.1
Size        : 4.6 M
Repo        : sl
Summary     : Fast Version Control System
URL         : http://git-scm.com/
License     : GPLv2
Description : Git is a fast, scalable, distributed revision control system with an
            : unusually rich command set that provides both high-level operations
            : and full access to internals.
            : 
            : The git rpm installs the core tools with minimal dependencies.  To
            : install all git packages, including tools for integrating with other
            : SCMs, install the git-all meta-package.
...
</code>



====== git コマンドラインインターフェイス ======
gitコマンドの書式は、次のようになります。
<code>
$ git <COMMAND> [ARGS]
</code>
<COMMAND>にはgitのサブコマンドを指定します。

<COMMAND>の一例:
^ <COMMAND> ^ 概要 ^
| config | コマンド環境設定 |
| init | リポジトリの初期化 |
| var | git変数の表示 |
| add | インデックスへの追加 |
| commit | インデックスへのコミット |
| log | リポジトリーの変更ログの表示　|
| diff | 特定のリビジョンとの差分の表示 |
| status | 状態の確認 |
| help | コマンドのヘルプ |

--help オプションでサポートされている全てのコマンドを表示することができます。また、helpコマンドの引数として調べたいコマンドを指定すると、より詳しいヘルプを得る事が来ます。

initをコマンドを調べる
<code>
$ git help init
...
GIT-INIT(1)                       Git Manual                       GIT-INIT(1)

NAME
       git-init - Create an empty git repository or reinitialize an existing one

SYNOPSIS
       git init [-q | --quiet] [--bare] [--template=<template_directory>]
       [--shared[=<permissions>]] [directory]

OPTIONS
       -q, --quiet
           Only print error and warning messages, all other output will be suppressed.
...
</code>

git, git help で得られるコマンドは良く使用するであろう一般的なもののみです。他にも、いくつかのコマンドが用意されているので、完全なドキュメントはオンラインマニュアル(man git)で確認すると良いでしょう。

====== 基本概念 ======
プロジェクトは、多くのファイルとディレクトリで構成された情報の塊ですが、それらは、ファイルの追加/更新/削除がなされ、変化していきます。gitでは、それら変化の歴史を任意のタイミングで記録していきます。記録された情報の変遷を辿ることができ、かつ自在に復元できます。

開発者は、新しくプロジェクトを立ち上げたり、あるいは既存のプロジェクトを入手し、過去の歴史を参考にしつつ、このプロジェクトに対して新たな歴史を加えていくことになります。

開発の過程で、コーディング、テスト、デバッグ、リファクタリング等の試行錯誤が繰り返し行われていくことになります。そういったファイル操作は、作業ツリーで行われます。この過程でコミットしてもよいと判断したファイルやディレクトリーを選定し、インデックス（ステージ）に登録しておきます。まだ、コミットすべきではないと判断したものは、インデックスには登録しません。インデックスに登録されていないオブジェクトは、作業ツリー内のみの変更であり、コミットされることはありません。

{{00-git-im.png}}

プロジェクト内の単純な流れ
  -- 開発者は、オブジェクトを作成します。
  -- コミットするにふさわしいと判断し、インデックスに追加(add)します。キャッシュされた状態であるとも言います。
  -- commitにより、"initial commit"というメッセージを添えて保存します。インデックスは削除されます。これが初期リビジョンとなります。
  -- 開発を進めます。
  -- コミットすべきオブジェクトをインデックスに追加しますが、この後、更なる検討をしたいので、コミットしません。
  -- さらに開発を進めます。
  -- コミットすべき対象ファイルをインデックスに追加します。
  -- "second commit"というメッセージを添えてコミットします。これが次のリビジョンとなります。
  -- さらに開発を進めます。
  
1と8の状態を取り戻す（リセット、あるいはチェックアウトする）ことが可能です。9の状態は作業ツリーにだけ存在します。

gitのリポジトリーは、外部のサーバーを必要とせず、ローカルマシンのみで完全な状態を維持できます。これは、オフラインでも有効に働く事を意味しますが、公開されてる外部のリモート・リポジトリーにデータを送ったり(push)、データを持ってきたり(pull)する事は可能です。

===== リポジトリー (repository) =====
gitの管理情報、および、管理対象となっている作業中のファイルやディレクトリー等全てを含む領域を指します。initによる初期化、または外部から複製(clone)によって作成されます。リポジトリー内には、プロジェクトの現在の状態と共にこれまでのコミットが含まれます。（bareリポジトリーは共有を目的とした作業ツリーを持たないリポジトリーです。後述します。）


==== コミット (commit) ====
リポジトリーに対して任意のオブジェクト（ファイル/ディレクトリ）を記録する事、あるいは、記録されたオブジェクトを指します。コミットによって、プロジェクト内のファイルの履歴が確かに保存されることになり、保存された状態にいつでも復元する事が可能です。

それぞれのコミットを識別するためのIDとして、cb136cb534a7a388f23cfbb672b6987df0bf284d のような、160ビットのハッシュ値が割り当てられ、正式にプロジェクトの履歴として記録されます。そして、その変更がどのような内容であるかを、人間が見て分かりやすいような変更の要約となる短いメッセージ（ログ）をつけておく事が必須となっています。

==== インデックス (index) ====
コミットされる候補となるオブジェクトを指します。開発者は、作業中のファイルの中からコミットに値するファイルを選定して、インデックスに登録しておきます。インデックスに登録されたオブジェクトは、次回のコミットの対象となります。インデックスは、ステージ（stage)とも呼ばれ、コミット対象の選定フェイズとして用いられます。

コミットの後、インデックス情報は破棄される一時的なものです。

このステージングという段階は、何をコミットすべきか？　というコミットの前の検討に貢献します。

==== 作業ツリー (working tree) ====
開発者が操作するファイルやディレクトリーを指します。開発者は作業ツリー内のファイルやディレクトリーに対して、追加/更新/削除を行います。開発の過程の任意のタイミングで、コミットすべきオブジェクトを選定し、インデックスに登録し、その後、作業の区切りがついた時点で、コミットします。コミットされる対象はインデックスに登録されたオブジェクトのみです。

====== 初期の流れ ======
gitでバージョン管理されたプロジェクトを作成するための最初の流れを紹介します。
  - リポジトリーの初期化
  - コミット対象ファイルの追加 (add)
  - 変更の確定 (commit)
  - ファイルの変更、add, commit...
 
** 本セクションで使用するコマンドとオプション **
^ COMMAND ^ OPTION ^ ARGS ^ 概要 ^
|init | | |gitリポジトリーの初期化。|
|config|%%--global%%|parameter value| 初期環境設定の.gitconfigに対する永続化。 | 
|status| | | 最新のコミットと作業ツリーとの比較。|
|add| | object |インデックスへの追加。|
|add| -u | | 更新されたオブジェクトをインデックスの追加。新規ファイルは追加されない。 |
|add| -A | | 追加、変更された全てのオブジェクトをインデックスに追加。|
|stage| | | addの別名 |
|commit| | | インデックスされたオブジェクトのコミット。 |
|commit| -a | | 更新されたオブジェクトのコミット。add -u / commit のショートカット。 |
|log| | | コミット履歴の確認。|
|log| -n | | nは数字。先頭からn個の履歴だけを表示。|
|log| %%--stat%%| | コミット履歴と変更統計の表示。|
|diff| | |作業ツリーと最新コミットの差分を表示。|
|show| | |最終コミット時の差分。|


===== 初期設定 =====
gitを使用するユーザーの初期環境設定を行います。利用者の名前、メールアドレスを指定します。設定した内容は、ホームディレクトリー内の.gitconifgというファイルに記録されます。

<code>
$ git config --global user.name 'Yuki Yamazaki'
$ git config --global user.email 'yyamazaki@knowd.co.jp'

$ cat .gitconfig
[user]
	name = Yuki Yamazaki
	email = yyamazaki@knowd.co.jp
...

</code>

===== リポジトリーの作成 =====
バージョン管理対象となるローカルなディレクトリを、gitのリポジトリーとして定義します。
ここでは、1.txtというファイルが含まれいてるmyprojectというディレクトリーを作成します。

<code>
$ mkdir myproject
$ cd myproject
$ echo "Hello World." > 1.txt
$ cat 1.txt
Hello World.
</code>

myprojectにリポジトリーとして必要な初期設定を行うには、git initコマンドを用います。そのディレクトリに.gitというgitの各種管理情報を含むサブディレクトリーが作成されます。

<code>
$ git init
Initialized empty Git repository in myproject/.git/

...
$ ls .git
HEAD  branches  config  description  hooks  info  objects  refs
</code>

===== 管理対象ファイルの追加 =====
gitリポジトリー内のステータスを確認するには git status コマンドを使用します。

<code>
$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	1.txt
nothing added to commit but untracked files present (use "git add" to track)
</code>

現在、インデックスされているファイルが存在しません。インデックスにファイルを追加するためには、git addコマンドを用います。.　を指定すると、カレントディレクトリ以下全てのファイルが管理対象となります。

<code>
$ git add .
$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#	new file:   1.txt
#
</code>
1.txtが新規にコミット対象となります。インデックスからこのファイルを削除するには、git rm --cachedを使用します。削除されると、追加する前の状態となります。

次いで、現在のファイルの状態をリポジトリーにコミットし記録します。git commit -m 'ログメッセージ'というコマンドを指定します。

<code>
$ git commit -m 'initial commit'
[master (root-commit) 351b3d0] initial commit
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 1.txt
...
</code>
1つのファイルが追加された事を示します。

プロジェクトに新しいリビジョンが作成された事をgit logで確認します。
<code>
$ git log
commit 417a38f1753d7e598714326f489aa02852f9f695
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 05:28:16 2011 +0900

    initial commit
	
</code>

git statusで確認すると、commitされるべき対象のファイルがないことが確認できます。
<code>
$ git status
# On branch master
nothing to commit (working directory clean)
</code>

以上で、現在のリポジトリーは最新の状態として記録され、作業ツリーとコミットの状態が一致していることを示します。

===== コミット後の変更 =====
コミット後、リポジトリー内のファイルに変更が加わると、gitはそこからの差分を追跡します。
1.txtに変更を加えgitが差分を認識している事を確認するために、git diffコマンドを使用します。

<code>
$ cat 1.txt
Hello World.

... "Hello git."を加える ...

$ cat 1.txt
Hello World. 
Hello git.

$ git diff
diff --git a/1.txt b/1.txt
index f534deb..308ef17 100644
--- a/1.txt
+++ b/1.txt
@@ -1 +1,2 @@
 Hello World.
+Hello git.

$ git status
# On branch master
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   1.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
</code>

1.txtが変更が、最後のコミットから変更されている事を表します。この変更をコミットする予定があるのであれば、git addコマンドを用いて、次回、コミットされる際の対象となる事を指定します。

<code>
$ git add 1.txt

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   1.txt
#
... no changes added to commit ... という出力が無くなる

</code>

1.txtの変更がステージングされた状態（インデックスに追加されているが、コミットされていない状態）で、2.txtという新たなファイルを作成します。

<code>
$ echo "new file." > 2.txt

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   1.txt
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	2.txt
</code>

1.txtはステージングされていますが、2.txtは未だである事を示します。この状態でコミットすると、次のリビジョンには1.txtの変更だけが記録されます。

2.txtの追加を記録するか否かは、開発者の判断次第です。2.txtの追加も記録したい場合は、addして下さい。

<code>
$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   1.txt
#	new file:   2.txt
#

</code>
これで、1.txtの変更と、2.txtの新規追加をコミットする準備ができました。



コミットし、次のリビジョンを作成します。
<code>
$ git commit -m "second commit"
[master 637cf4e] second commit
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 2.txt
</code>

ログを確認します。
<code>
$ git log
commit 637cf4ec82695f8e4b6bee4ea648c2966b070edc
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 05:41:46 2011 +0900

    second commit

commit 417a38f1753d7e598714326f489aa02852f9f695
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 05:28:16 2011 +0900

    initial commit
</code>

最後のコミットで行われた変更を表示します。
<code>
$ git show
commit e679936e51eb702a5c5305cdf73b57138694c774
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 07:01:39 2011 +0900

    second commit

diff --git a/1.txt b/1.txt
index f534deb..308ef17 100644
--- a/1.txt
+++ b/1.txt
@@ -1 +1,2 @@
 Hello World.
+Hello git.
diff --git a/2.txt b/2.txt
new file mode 100644
index 0000000..f0129ca
--- /dev/null
+++ b/2.txt
@@ -0,0 +1 @@
+new file.

</code>

===== 管理対象から外したいファイルの指定 (gitignore) =====
gitのプロジェクトディレクトリに、.gitignoreというファイルを作成し、その中にgitの管理対象から外したいオブジェクトを記述することができます。記述としては、*, ?, [] などのファイル名ようメタキャラクターが使用できます。

.gitignoreの例）
<code>
# vim swap file.
.*.swp

# Mac Fider.
.DS_Store

# gEdit backkup file.
*~

# LibreOffice lock files.
.~lock.*

# my test directory
/mytest
</code>

/mytest/　という指定は、プロジェクトのトップを頂点とした絶対的な指定で /subdirectory/mytest はマッチしません。
mytest/ は相対的な指定で /subdirectory/mytest というディレクトリもマッチします。

指定の先頭に ! を指定すると、無視しないファイルの指定となります。

====== 取り消し・リセット ======
開発を進めていく過程で、元の状態に戻りたい場合が出てくるかもしれません。gitは変更履歴を維持しているので任意の状態までさかのぼる事が可能です。取り消しやリセット操作には様々なレベルが存在します。

** 本セクションで使用するコマンドとオプション **
^ COMMAND ^ OPTION ^ ARGS ^ 概要 ^
| checkout | | object |コミットからフィルを取り出す。|
| commit | %%--amend%% | | 最新のコミットの訂正。|
| reset | | リセット対象 |コミットをリセット。作業ツリーは維持される。|
| reset | %%--hard%% | リセット対象 |コミットをリセット。作業ツリーを同期。|


===== コミット前の変更の取り消し (checkout) =====
作業ツリーに行った変更を取り消してもとに戻す場合、つまり、コミットされた状態のファイルを引き出し作業ツリーに展開するには、checkoutコマンドを用います。
この作業は、コミットされた最新の状態からやり直す事を意味します。作業ツリーに対する変更を取り消してしまうので、注意して下さい。

1.txtに、"wrong line."という一行を追加し、それを取り消します。
<code>
$ echo "wrong line." >> 1.txt 

$ cat 1.txt 
Hello World.
Hello git.
wrong line.

$ git diff
diff --git a/1.txt b/1.txt
index 308ef17..9ae4596 100644
--- a/1.txt
+++ b/1.txt
@@ -1,2 +1,3 @@
 Hello World.
 Hello git.
+wrong line.

...最新のコミットの状態と比べ、+wrong line.が追加されています。

...最新のコミットを取得する事で、元に戻します。
$ git checkout 1.txt

$ cat 1.txt 
Hello World.
Hello git.

</code>

インデックスに追加後に、取り消しを行いたい場合は、checkout HEAD を用いて下さい。
<code>
$ echo "wrong line." >> 1.txt 

$ cat 1.txt 
Hello World.
Hello git.
wrong line.

$ git add 1.txt

$ git checkout 1.txt
$ cat 1.txt 
Hello World.
Hello git.
wrong line.

... addしているので、変更は取り消されません。

$ git checkout HEAD 1.txt 

$ cat 1.txt 
Hello World.
Hello git.

... 変更とインデックスへの追加が取り消されます。
</code>

===== 直前のコミットの訂正 (--amend) =====
コミットした内容を訂正するには、訂正後、--amendオプションを指定して再度コミットします。-m で、新しいログメッセージを指定できます。もし、ログメッセージ変更の必要がなければ、-C HEAD を指定します。
<code>
$ cat "miss" >> 1.txt
$ git commit -a -m "miss commit"
[master 4062bd9] miss commit
 1 files changed, 1 insertions(+), 0 deletions(-)
 
 $ echo "amend" >> 1.txt
 
 ...新しくコミットするのではなく、直前のコミットを置き換える...
$ git commit --amend -a -m 'amend commit'
[master 93d986a] amend commit
 1 files changed, 2 insertions(+), 0 deletions(-)


$ git log
commit 93d986a65bb294940180a9839fc827a1898fcdf3
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 18:34:43 2011 +0900

    amend commit

commit e679936e51eb702a5c5305cdf73b57138694c774
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 07:01:39 2011 +0900

    second commit

...  "miss commit"が訂正されて記録される ...
</code>



===== コミット情報の削除 (reset) =====
特定のコミットの状態に復帰したい場合は、resetを使用します。
git rest の後、どのコミット状態に戻るかを指定します。
戻り先には、コミット名を指定します。
この作業は、プロジェクトの歴史を消し去ることになるので、注意が必要です。%%--hard%%を指定すると作業ツリーを更新し、二度ともとに復帰できなくなるので、更なる注意が必要です。

コミット名として次のものが使用できます。

| HEAD | 最も最新のコミット |
| logで表示されるハッシュ値 | git log で得られるハッシュ値 |
| blameで表示されるハッシュ値 | git blame で得られるハッシュの先頭値 |
| タグ名 | git tag で指定した任意のタグ名 |
| ブランチ名 | ブランチの先頭 |

上記で指定したコミット名以前のコミットを相対的に指定する事が可能です。

HEADの例
^コミット名^1つ前^2つ前^3つ前^N個前^
| HEAD | %%HEAD^%% | %%HEAD^^%% | %%HEAD^^^%% | ハットを続ける... |
| HEAD | HEAD~1 | HEAD~2 | HEAD~3 | HEAD~N |

<code>
...誤ったコミットを3回繰り返す...

$ touch x ...不要なファイルx
$ git add -A
$ git commit -a -m "NG commit 1"

$ touch y ...不要なファイルy
$ git add -A
$ git commit -a -m "NG commit 2"

$ touch z ...不要なファイルz
$ git add -A
$ git commit -a -m "NG commit 3"


...　履歴の確認 ...
$ git log
commit fea9efb6d9c20717e440e1e66b5b1c7c2b483777
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:04:41 2011 +0900

    NG commit 3

commit e76bc32daafe12d0adcdb67670bb510cbff1518e
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:03:21 2011 +0900

    NG commit 2

commit 3486e0bf5597a728eb40f522c3c6527232b3ab8f
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:02:59 2011 +0900

    NG commit 1

commit e679936e51eb702a5c5305cdf73b57138694c774
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 07:01:39 2011 +0900

    second commit

... 最新のコミット内容の確認 ...
$ git show 
commit fea9efb6d9c20717e440e1e66b5b1c7c2b483777
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:04:41 2011 +0900

    NG commit 3

diff --git a/z b/z
new file mode 100644
index 0000000..e69de29


... 一つ前のコミット内容の確認 ...
$ git show HEAD^
または
$ git show HEAD~1
commit e76bc32daafe12d0adcdb67670bb510cbff1518e
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:03:21 2011 +0900

    NG commit 2

diff --git a/y b/y
new file mode 100644
index 0000000..e69de29

... 二つ前のコミット内容の確認 ...
$ git show HEAD^^
または
$ git show HEAD~2
commit 3486e0bf5597a728eb40f522c3c6527232b3ab8f
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:02:59 2011 +0900

    NG commit 1

diff --git a/x b/x
new file mode 100644
index 0000000..e69de29


... 二つ前のコミットにリセットする ...
$ git reset HEAD^^
または
$ git reset HEAD~2

$ git log
commit 3486e0bf5597a728eb40f522c3c6527232b3ab8f
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:02:59 2011 +0900

    NG commit 1

commit e679936e51eb702a5c5305cdf73b57138694c774
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 07:01:39 2011 +0900

    second commit

commit aa0e4f5b1a860119fa3235ce8230b8e7ba259ffa
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 06:57:03 2011 +0900

    initial commit

... xが作成された "NG commit 1"までリセットされる ...

... 作業ツリーに変更は無いことを確認 ...
$ ls
1.txt  2.txt  x  y  z

$ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	y
#	z
nothing added to commit but untracked files present (use "git add" to track)

</code>

===== 作業ツリーを同期 (reset --hard) =====
通常のresetでは、コミット情報を削除しますが、作業ツリーは維持されます。コミット情報の削除とともに作業ツリーもそれに合わせたい場合は、--hardオプションを指定します。

<code>
$ ls 
1.txt  2.txt  x  y  z


$ git log
commit 3486e0bf5597a728eb40f522c3c6527232b3ab8f
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 08:02:59 2011 +0900

    NG commit 1

commit e679936e51eb702a5c5305cdf73b57138694c774
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 07:01:39 2011 +0900

    second commit

commit aa0e4f5b1a860119fa3235ce8230b8e7ba259ffa
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 06:57:03 2011 +0900

    initial commit

... x y z は、"NG commit 1"以降に作成された ...

... 最新のコミットである、"NG commit 1"が実行された前の状態に、作業ツリーも含めて戻す ...

$ git reset --hard HEAD^
HEAD is now at e679936 second commit

$ git log
commit e679936e51eb702a5c5305cdf73b57138694c774
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 07:01:39 2011 +0900

    second commit

commit aa0e4f5b1a860119fa3235ce8230b8e7ba259ffa
Author: Yuki Yamazaki <yyamazaki@knowd.co.jp>
Date:   Sat Oct 22 06:57:03 2011 +0900

    initial commit

$ ls
1.txt  2.txt  y  z

... "NG commit 1"の際に作成されたファイル x も削除される ...

... y z は、インデックスされていない状態で残っている ...
$ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	y
#	z
nothing added to commit but untracked files present (use "git add" to track)

</code>

===== 作業ツリーの誤った削除や変更を取り消す =====
gitにコミットされたオブジェクトは、容易に復活可能です。
<code>
$ ls 
1.txt  2.txt

$ rm *
$ ls
... ファイルが無くなっているが、コミットが残っていれば復活可能 ・・・

$ git reset --hard HEAD
HEAD is now at e679936 second commit

$ ls
1.txt  2.txt

</code>

===== コミットの取り消し (blame/revert) =====
revertは、resetと異なりコミットの履歴自体を削除することはありませんが、特定のコミットで行われた変更を無かった事にするために役立ちます。

1 -> 2 -> 3 とコミットが連続で実行された後に、revert 2 とすると、2の変更を取り消けしたじょうたいにしてコミットしようとします。多くの場合、時系列的な依存によりコンフリクトが発生しますので、コミットは失敗します。

3回のコミットによって、作られたcommit.txtファイルがあるとします。
<code>
$ cat commit.txt 
commit 1
commit 2
commit 3

$ git log
commit bb0654df5e9831e9eda7ee8c1ef1d57d29c31875
    commit 3

commit 05c1aa742ae4597dd0747db29cca97413538c01c
    commit 2

commit d4742e27e7b187bd0f122708aa94f85c43e7c521
    commit 1

</code>
ぞれぞれの行がどのコミットによって作られたかを調べるには、blameを使用します。

<code>
$ git blame commit.txt 
^d4742e2 (Yuki Yamazaki 2011-10-24 07:05:17 +0900 1) commit 1
05c1aa74 (Yuki Yamazaki 2011-10-24 07:05:17 +0900 2) commit 2
bb0654df (Yuki Yamazaki 2011-10-24 07:05:17 +0900 3) commit 3
</code>

commit 2を打ち消すには、05c1aa74をrevertします。コンフリクトが発生しない場合、指定したコミットが取り消された状態でコミットされます。コンフリクトが発生しコミットには到りません。
<code>
$ git revert 05c1aa74
Automatic revert failed.  After resolving the conflicts,
mark the corrected paths with 'git add <paths>' or 'git rm <paths>'
and commit the result.
$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD <file>..." to unstage)
#   (use "git add/rm <file>..." as appropriate to mark resolution)
#
#	both modified:      commit.txt
#
no changes added to commit (use "git add" and/or "git commit -a")

</code>
コンフリクトを解消します。
<code>
... commit.txt ...
commit 1
<<<<<<< HEAD
commit 2
commit 3
=======
>>>>>>> parent of 05c1aa7... commit 2

... 修正 ...
commit 1
commit 3

$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   commit.txt
#

$ git commit -m 'revert 05c1aa7'
[master 4e18e73] revert 05c1aa7
 1 files changed, 0 insertions(+), 1 deletions(-)

</code>

以上で、特定のコミットでの変更を修正することができます。

===== コミット履歴の編集 (rebase) =====
rebaseを使用すると、コミットされた履歴のログメッセージを編集することができます。

編集可能な操作は次のものです。
  * 順番の変更
  * コミットメッセージの変更
  * コミットの圧縮 (squash)
  * コミットの分割 (fixup)

編集対象の先頭となるコミットをrebaseの引数として指定します。
<code>
$ git log
commit 7df0ac8cb5058bae5e8e0f989e00ebbea409c189
    commit 5

commit 636d4c054a4a008c3645bf1875bb794be03b4a9c
    commit 4

commit 65628a4ba88c3945bd63a3530e99b4c8144cdda6
    commit 3

commit f62520cca7fb2d207f2535def5fae35393232ceb
    commit 2

commit 33742dde71ea10fb765a74db48dc9dc8d23b971d
    commit 1
</code>

commit 1 より後のコミット（commit 2以降）を編集するには、次のように指定します。-iは対話的な変更を意味します。
<code>
$ git rebase -i 33742dde71ea10fb765a74db48dc9dc8d23b971d

...エディターが起動する...
pick f62520c commit 2
pick 65628a4 commit 3
pick 636d4c0 commit 4
pick 7df0ac8 commit 5

# Rebase 33742dd..7df0ac8 onto 33742dd
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#
</code>

上部に、コミットの履歴が古いものから順番に並び、それらのコミットに対する変更を、pick, reward, edit, squash, fixupから選びます。また、順番を変更すると並び替えが行われます。

===== squash / fixup =====
一つ前のコミットとまとめられます。
<code>
pick 8629827 commit 2
pick 4bf6926 commit 3
squash 8bfeaee commit 4
pick 9b23cb3 commit 5
</code>
squashを指定すると、commit 3とcommit 4をまとめ、新たなメッセージを指定できます。エディターを保存終了すると、メッセージの編集に切り替わりますので、保存終了します。fixupを指定すると、メッセージの編集はせず、commit 4が消え、commit 3にまとめられます。

===== edit / reward =====
r(reward)を指定すると、メッセージの内容を変更できます。
<code>
pick 69251f3 commit 2
pick 6b9664c commit 3
reword 8ea64b0 commit 4
pick a6da343 commit 5
</code>
rewordを指定すると、メッセージを編集する画面に切り替わりますので、保存終了すると、メッセージを変更できます。editを指定すると、指定したコミットがHEADになった無名ブランチ上での操作となりますので、commit --amendを指定することでコミットメッセージを変更できます。rebaseを進めるためには、rebase --continueを実行します。
<code>
$ git commit --amend -m 'amending message'
$ git rebase --continue
Successfully rebased and updated refs/heads/master
</code>


====== タグ ======
gitは、コミットに対してSHA1アルゴリズムを用いた16進数40桁の数値を用いて、コミットにユニークな番号を自動的に割り当てコミットの識別に使用することができます。このハッシュ値を人間が記憶するのは事実上無理なので、このハッシュ値に対して別名である「タグ」を定義することができます。これは、HEADと同様に、特定の時点を示すのに役立ちます。

タグは、.git/refs/tags ディレクトリに名前をファイル名として保存されます。
名前はスペースを含むことはできません。

** 本セクションで使用するコマンドとオプション **
^ COMMAND ^ OPTION ^ ARGS ^ 概要 ^
| tag | | tagname |現時点のコミットに対するタグの定義。|
| tag | -f | tagname | タグの強制的な定義、置き換え。|
| tag | -l | | リポジトリー内に定義されているタグの一覧。|
| tag | -d | tagname | タグの削除。 |
| rev-parse | | tagname | 指定したタグに対応するハッシュ値の表示。 |


<code>
... 現在のコミットに 0.9 というタグを設定 ...
$ git log -1
$ git log -1
commit 93d986a65bb294940180a9839fc827a1898fcdf3
...

$ git tag 0.9

$ git tag -l
0.9

$ git rev-parse 0.9
93d986a65bb294940180a9839fc827a1898fcdf3

... コミットを3つ進める ...
$ touch x
$ git add .
$ git commit -m 'test commit 1'

$ touch y
$ git add .
$ git commit -m 'test commit 2'

$ touch z
$ git add .
$ git commit -m 'test commit 3'

$ ls
1.txt  2.txt x y z

$ git log
commit 99217da61f70b56116543be8599ecce388637a84
    test commit 3
...
commit 19fa897d094ef387921f92b8f474fc542857642c
    test commit 2
...
commit 6611bf42a93e1d565e0121653c111d096b4cb6a4
    test commit 1
...
commit 93d986a65bb294940180a9839fc827a1898fcdf3
    amend commit

... これらの3つコミットを取り消し、0.9というタグをつけたときの状態にハードリセットする ...
$ git reset --hard 0.9

$ ls
1.txt 2.txt

$ git log -1
commit 93d986a65bb294940180a9839fc827a1898fcdf3
    amend commit
...

</code>


====== バックアップ ======
作成したリポジとリーのバックアップを取るためのコマンドがいくつか用意されています。


** 本セクションで使用するコマンドとオプション **
^ COMMAND ^ OPTION ^ ARGS ^ 概要 ^
| archive |%%--format, --prefix, -o%% | commit-ish |tar, zip等のアーカイブを作成する。|
| clone | | 複製元 複製先| 他のディレクトリーまたは、リモートサーバーに複製を行う。|

===== アーカイブの作成 (archive) =====
git archive --listで、zip, tar等サポートしているアーカイブ形式を得ることができます。得られた形式をもとに --format オプションに形式を指定します。アーカイブには作業ツリーだけが含まれ、gitの履歴や管理情報は含まれません。

--prefixに、アーカイブする際のここのファイルの前につけるファイル名やディレクトリ名を指定します。通常の使用では、myproject/ 等、サブディレクトリを指定すると良いでしょう。

-o オプションに、ファイル名を指定します。また、どのコミットをアーカイブするかを指定します。最新のコミットをアーカイブしたければ、HEADを指定します。

以下は、最新のコミットを、myprojectというサブディレクトリーつくり、tar形式で/tmp/myproject.tar という名前でアーカイブする例です。
<code>
$ git archive --format tar --prefix myproject/ HEAD -o /tmp/myproject.tar

$ tar tvf /tmp/myproject.tar 
drwxrwxr-x root/root         0 2011-10-22 18:37 myproject/
-rw-rw-r-- root/root        35 2011-10-22 18:37 myproject/1.txt
-rw-rw-r-- root/root        10 2011-10-22 18:37 myproject/2.txt
</code>

===== クローン (clone) =====
リポジトリーの状態の複製を作成します。
cloneに続いて複製元、複製先を指定します。それぞれには、リモートのgitリポジトリーを指定することもできます。
以下は、カレントディレクトリのgitリポジトリーを/tmp/myproject.gitに複製している例です。

クローンされたリポジトリーは、gitの履歴や管理情報を含みます。

<code>
$ git clone . /tmp/myproject.git
Initialized empty Git repository in /tmp/myproject.git/.git/

$ cd /tmp/myproject.git
$ git log
....
</code>

複製されたcloneは、何処から複製されたか？　という情報を保持しています。
<code>
$ git var -l
...
remote.origin.url=/home/gittest/myproject
...
</code>
cloneされたリポジトリーは単体で使用し続けることはできますが、pushを通じたオリジナルに対する更新は拒否されます。
一方、オリジナルがそのURLで存在していれば、pullを通じてオリジナルの変更をマージする事は可能です。

この意味で、オリジナルとクローンは対称とはなっていません。

====== ブランチ ======
gitでは、デフォルトで master というブランチ上で作業を行っています。
このブランチ上にコミットが、連なる形を取ります。

\\  
{{01-git-im.png}}

** 本セクションで使用するコマンドとオプション **
^ COMMAND ^ OPTION ^ ARGS ^ 概要 ^
| branch | | | ブランチの一覧表示。|
| branch | | newbranch| ブランチの新規作成。|
| branch | -b | newbranch | ブランチの新規作成とチェックアウト。|
| branch | -d | deletebranch | ブランチの削除。|
| branch | -D | deletebranch | ブランチの強制削除。|
| checkout | | newbranch | ブランチの最新版を作業ツリーにチェックアウト。|
| merge | | branch | ブランチのマージ。 |
| merge | %%--squash%% | branch | squashマージ。 |
| cherry-pick | | commit-ID | 特定のコミットの取り込み。 |


現在、リポジトリー上に存在するブランチを表示するには、branchコマンドを使用します。
<code>
$ git branch
* master
</code>

* は、現在作業中のブランチを示しています。

masterブランチから、別のブランチを作ることができます。新しいブランチの変更は masterと別のコミットを持つことができ、任意のタイミングで、別のブランチにマージすることができます。

\\  
{{02-git-im.png}}

===== ブランチの作成と切り替え =====
ブランチを作成するには、branchコマンドを使用し、ブランチを作業ツリーに反映するにはcheckoutを使用します。

ここでは、experimentalというブランチを作成します。
<code>
$ git branch experimental

$ git branch
  experimental
* master
</code>

現在、作業ツリーがmasterである事を示します。これを、experimetalに変更するには、checkoutを実行します。
<code>
$ git checkout experimental
Switched to branch 'experimental'

$ git branch
* experimental
  master
  
$ git status
# On branch experimental
nothing to commit (working directory clean)

</code>

experimentalに対して、いくつかのコミットを行います。
<code>
$ touch ex1
$ git add .
$ git commit -m 'ex1'

$ touch ex2
$ git add .
$ git commit -m 'ex2'

$ git log
commit 44792d15527c89f2395e38f4d4d9084b3e9e0d74
    ex2

commit 2f49d84fc1c1ddc665a06bfb6d7ad50f44d34ae3
    ex1

commit 93d986a65bb294940180a9839fc827a1898fcdf3
    amend commit

$ ls
1.txt  2.txt  ex1  ex2

</code>

masterの状態を確認します。作業ツリーをmasterに切り替え、状態を確認します。
<code>
$ git checkout master
Switched to branch 'master'

$ git branch
  experimental
* master

$ touch m1
$ git add .
$ git commit -m 'm1'

$ touch m2
$ git add .
$ git commit -m 'm2'

$ ls
1.txt  2.txt m1 m2

$ git log
commit 12b1443b140602dccb682aff9ebe0997387bc549
    m2

commit de5064f20dedfb9be6e1bc62c3cded2f2bdd1e90
    m1

commit 93d986a65bb294940180a9839fc827a1898fcdf3
    amend commit
...	
</code>

一つのリポジトリーが、masterから分岐したブランチを持てる事を確認できます。

===== マージ (merge) =====
上記の例では、masterブランチに m1, m2 2つのファイルに対するコミット、experimentalブランチにex1, ex2 2つのファイルに対するコミットを行いました。experimentalの変更を masterにマージするには、mergeコマンドを使用します。

<code>
$ git checkout master
Already on 'master'

$ git merge experimental
Merge made by recursive.
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 ex1
 create mode 100644 ex2

$ git log
commit b2a4998f6d155fab7b9a03bda2bf3acc33609c60
    Merge branch 'experimental'
	
commit 12b1443b140602dccb682aff9ebe0997387bc549
    m2

commit de5064f20dedfb9be6e1bc62c3cded2f2bdd1e90
    m1

commit 44792d15527c89f2395e38f4d4d9084b3e9e0d74
    ex2

commit 2f49d84fc1c1ddc665a06bfb6d7ad50f44d34ae3
    ex1

....

$ ls
1.txt  2.txt  ex1  ex2  m1  m2

</code>

ブランチが持つ履歴もマージされます。このマージを取り消すには、resetが使用できます。
<code>
$ git reset --hard HEAD^
$ git log
...
commit 12b1443b140602dccb682aff9ebe0997387bc549
    m2

commit de5064f20dedfb9be6e1bc62c3cded2f2bdd1e90
    m1
...

$ ls
1.txt  2.txt  m1  m2
</code>

==== squash merge (--squash)====
通常のマージでは、ブランチのコミット履歴を全て取り込みますが、外部のブランチのコミットを1つのコミットに取りまとめてマージするには、marge --squashを指定します。コミットは行われないので手動でコミットします。
<code>
$ git checkout experimental
$ git log
commit 44792d15527c89f2395e38f4d4d9084b3e9e0d74
    ex2

commit 2f49d84fc1c1ddc665a06bfb6d7ad50f44d34ae3
    ex1
	

$ git checkout master
 git log
commit 12b1443b140602dccb682aff9ebe0997387bc549
    m2

commit de5064f20dedfb9be6e1bc62c3cded2f2bdd1e90
    m1

$ git merge --squash experimental
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	new file:   ex1
#	new file:   ex2
#

$ git commit -m "squash merge"
[master 84cea18] squash merge
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 ex1
 create mode 100644 ex2

$ git log
commit 84cea182310ee427b0e1b64593449704be4038a4
    squash merge

commit 12b1443b140602dccb682aff9ebe0997387bc549
    m2

commit de5064f20dedfb9be6e1bc62c3cded2f2bdd1e90
    m1
 
</code>

==== cherry-pick ====
他のブランチから、全てではなく、特定のコミットのみを反映させることができます。
以下の例では、experimentalブランチのex1のコミットだけを取り込みます。
<code>
$ git branch
  experimental
* master

$ git log experimental ex1

commit 2f49d84fc1c1ddc665a06bfb6d7ad50f44d34ae3
    ex1

$ git cherry-pick 2f49d84fc1c1ddc665a06bfb6d7ad50f44d34ae3
Finished one cherry-pick.
[master 47c3b9a] ex1
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 ex1

$ ls
1.txt  2.txt  ex1  m1  m2


$ git log
commit 47c3b9af30b386af45aac71fb8cb31c95b86d132
    ex1
	
commit 12b1443b140602dccb682aff9ebe0997387bc549
    m2

</code>


===== コンフリクト =====
上記のマージが問題なく動作するのは、変更にコンフリクトが無いためです。それぞれのブランチで同一のオブジェクトに対して異なる変更を加えた場合、コンフリクトが発生します。

基本的に、マージされる予定のあるブランチ間では、コンフリクトは避けるように作業すべきですが、開発者がそれぞれ、独自に開発を行うとコンフリクトを避ける事は難しいかも知れませんし、同一のオブジェクトを同時に編集した場合、多くの場合コンフリクトは不可避です。

コンフリクトの解消を、誰がどのように行うかは、プロジェクトの体制や性格によります。

ここでは、masterブランチと、experimentalブランチとで、コンフリクトを発生させてみます。

masterブランチ: 1.txtにauther: Aliceと書き込みます。
<code>
$ git branch
  experimental
* master

$ echo "author: Alice" >> 1.txt

$cat 1.txt
...
author: Alice

$ git add .
$ git commit -m 'alice'
[master 6e44a35] alice
 1 files changed, 1 insertions(+), 0 deletions(-)
</code>

experimentalブランチ: 1.txtにauthor: Bobと書き込みます。
<code>
$ git checkout experimental
Switched to branch 'experimental'

$ git branch
* experimental
  master
  
$ echo "author: Bob" >> 1.txt

$ cat 1.txt 
...
author: Bob

$ git add .
$ git commit -m 'bob'
[experimental 34e3db9] bob
 1 files changed, 1 insertions(+), 0 deletions(-)

</code>

ぞれぞれのブランチが、1.txtに異なる変更を加えています。これをマージするとコンフリクトが発生します。コンフリクトが発生すると、自動的なコミットは行われず、解消を待ちます。
<code>
$ git checkout master

$ git merge experimental
Auto-merging 1.txt
CONFLICT (content): Merge conflict in 1.txt
Automatic merge failed; fix conflicts and then commit the result.

$ git status
# Unmerged paths:
#   (use "git add/rm <file>..." as appropriate to mark resolution)
#
#	both modified:      1.txt
#

</code>

コンフリクトが発生しているファイルは次のような、両方のファイルの内容が以下のフォーマットで組み合わされた状態となっています。
<code>
Hello World.
Hello git.

<<<<<<< HEAD
author: Alice
=======
author: Bob
>>>>>>> experimental
</code>

これを、エディターやマージツールを使って、解消します。
今回は以下のように解消しました。

<code>
Hello World.
Hello git.

author: Alice
author: Bob
</code>

解消が完了したら、これをコミットします。
<code>
$ git add .
$ git commit -m 'resolve conflict'
[master f183689] resolve conflict
</code>

===== ブランチの削除　======
ブランチの削除は、branch -d で行うことができます。フルマージされていないブランチは-dオプションでは削除できません。-Dオプションを使用します。
<code>
$ git branch
  experimental
* master

$ git branch -d experimental
error: The branch 'experimental' is not fully merged.
If you are sure you want to delete it, run 'git branch -D experimental'.

$ git merge experimental

$ git branch -d experimental
Deleted branch experimental (was 44792d1).

$ git branch
* master

</code>


====== プロジェクトの分散化 ======
自分のラップトップだけで作業している場合、リポジトリーは一カ所に存在し、一人の開発者が変更を行いますが、複数箇所で、複数人が同時に開発する場合は、いくつかの準備が必要となります。

\\ 
{{03-git-im.png}}

それぞれの開発者の振る舞い
  * 開発者Aは、最初のリポジトリーをつくり、それをbareリポジトリーとして公開した。
  * 開発者Bは、開発者Aの作ったリポジトリーをクローンにより入手した。
  * 開発者Cは、開発者Aが公開したbareリポジトリーをもとに開発に参加し、さらに自作分を含めbareリポジトリーとして公開した。
  * 開発者Dは、開発者A,B,CとともにAの公開したbareリポジトリーを使って開発に参加した。

===== git URL =====

gitリポジトリーを指し示すURLとして、以下の例が有効です。

man git-cloneより

  * %% ssh://[user@]host.xz[:port]/path/to/repo.git/%%
  * %% git://host.xz[:port]/path/to/repo.git/%%
  * %% http[s]://host.xz[:port]/path/to/repo.git/%%
  * %% ftp[s]://host.xz[:port]/path/to/repo.git/%%
  * %% rsync://host.xz/path/to/repo.git/%%

  * %% [user@]host.xz:path/to/repo.git/%%
  * %% ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/%%
  * %% git://host.xz[:port]/~[user]/path/to/repo.git/%%
  * %% [user@]host.xz:/~[user]/path/to/repo.git/%%

  * %% /path/to/repo.git/%%
  * %% file:///path/to/repo.git/%%

** 本セクションで使用するコマンドとオプション **
^ COMMAND ^ OPTION ^ ARGS ^ 概要 ^
| init | %%--bare%% | | bareリポジトリーの初期化。 |
| push | | リポジトリー ブランチ | 指定したリポジトリーにブランチをpush。|
| clone | %%--bare%% | 複製元 複製先 | 複製元からbareリポジトリーを複製。|
| push | | [remote] [branch] | デフォルトのリモートリポジトリーにpush |
| pull | | [remote] [branch] | デフォルトのリモートリポジトリーからpull |


===== bare リポジトリー =====
リポジトリーには、non-bareリポジトリーと、bareリポジトリーの2種類があります。
non-bareリポジトリーは、gitの管理情報とともに作業ツリーを持ち、それのみでファイル操作が可能です。一方、bareリポジトリーは管理情報やコミット履歴を持ちますが、作業ツリーを持ちません。bareリポジトリーは、複数のリポジトリー間でのコミット情報を交換する目的で作成され、pushとpullの両方を受け付ける事ができます。

bare --- 最低限の、最小限の、むきだしの

bareリポジトリーは、git変数core.bareがtrueとなり、non-bareリポジトリーはfalseとなります。
<code>
$ git var -l
...
core.bare=false
...
</code>

bareリポジトリーには慣例的に、myproject.gitのように、サフィックスに.gitを付け、non-bareリポジトリーと区別します。


bareリポジトリーを作成するには、ディレクトリを作成し、init --bare を実行します。その後、元になるリポジトリーをpushします。

<code>
$ git init --bare myproject.git/
$ cd myproject.git
$ ls
HEAD  branches  config  description  hooks  info  objects  refs

$ git var -l
core.bare=true


... myprojectのmasterブランチを myproject.git にpush ...

$ cd ~/myproject

$ git push ~/myproject.git master

Counting objects: 7, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (7/7), 502 bytes, done.
Total 7 (delta 0), reused 7 (delta 0)
Unpacking objects: 100% (7/7), done.
To /home/gittest/myproject.git
 * [new branch]      master -> master
 
</code>

bareリポジトリーを作成し、プロジェクトをpushするという作業は、clone --bareで同様のことが可能です。

<code>
$ git clone --bare myproject myproject.git
</code>

上記の方法で、作られた、オリジナルとbareリポジトリーの間に関連性はありません。それぞれが、独立して動作することになります。

bareリポジトリーからは、作業ツリーをもつクローンが生成できます。クローンは、bareリポジトリーの場所(URL)を維持しており、push, pullが可能です。
<code>
$ git clone myproject.git myproject.clone
Initialized empty Git repository in /home/gittest/myproject.clone/.git/

$ cd myproject.clone

$ ls
1.txt  2.txt

</code>

===== push と pull =====
クローンの元となったリポジトリーは、git変数の、remote.origin.urlに記録されています。このオリジナルのURLで起きた変更を持ってくる時に使うのが pullであり、クローン側での変更をオリジナルに反映させるのがpushです。

オリジナルからクローンされたリポジトリーは、クローン直後はオリジナルと同じなので、pushとpullは次のようなレスポンスを返します。
<code>
$ git pull
Already up-to-date.

$ git push
Everything up-to-date
</code>

ローカル（クローンされた側）で、ファイルに変更を加えコミットし、それをオリジナルに通知する場合は、pushを使用します。
<code>
$ echo "add at clone side." >> 1.txt 
$ git add .
$ git commit -m 'modify at clone.'
[master 8d7ae08] modify at clone.
 1 files changed, 1 insertions(+), 0 deletions(-)
  
 $ git push
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 312 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
To /home/gittest/myproject.git
   e679936..8d7ae08  master -> master

... オリジナルに変更が反映されている事を確認 ...

$ cd ~/myproject.git
$ git log
commit 8d7ae08909a616c5853a839557f217f117ad47a0
    modify at clone.

</code>

例として、一つのgitリポジトリからクローンされた2つのリポジトリー間でのpush/pullを確認します。
開発者aliceとbobが、同時に、myproject.gitからクローンを作成します。
<code>
... alice ...
$ git clone myproject.git myproject.alice

... bob ...
$ git clone myproject.git myproject.bob
</code>

aliceは、1.txtに "my name is Alice."　を追加し、コミットします。同時期にbobも同じ事をします。
<code>
... myproject.alice ...
$ echo "my name is Alice." >>  1.txt
$ git commit -a -m 'alice modify'

... myproject.bob ...
$ echo "my name is Bob." >>  1.txt
$ git commit -a -m 'bob modify'
</code>

それぞれ、Alice, Bobの順にオリジナルにpushします。
<code>
.... Alice ...
$ git push
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 308 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
To /home/gittest/myproject.git
   e679936..fd68bba  master -> master


... Aliceは成功します ...

.... Bob ....
$ git push
To /home/gittest/myproject.git
 ! [rejected]        master -> master (non-fast-forward)
error: failed to push some refs to '/home/gittest/myproject.git'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes before pushing again.  See the 'Note about
fast-forwards' section of 'git push --help' for details.

.... Bob はリジェクトされます...
</code>

これは、1.txtをBobがpullしたときの状態から変更(Aliceによって)されていたためにおこるものです。この場合、Bobはオリジナルの最新の状態をpullし、オリジナルの履歴を再度取得し、競合を解決する必要があります。

<code>
$ git pull
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From /home/gittest/myproject
   e679936..fd68bba  master     -> origin/master
Auto-merging 1.txt
CONFLICT (content): Merge conflict in 1.txt
Automatic merge failed; fix conflicts and then commit the result.

</code>

Bobはコンフリクトを解決します。
<code>
Hello World.
Hello git.
<<<<<<< HEAD
my name is Bob.
=======
my name is Alice.
>>>>>>> fd68bbaf65e78633a4a82403ea00da0642a4d8fe

... を、以下のように解決 ...

Hello World.
Hello git.
my name is Alice.
my name is Bob.
</code>

競合が解決したので、再度コミットし、pushします。
<code>
$ git commit -a -m 'bob modify 2'
[master 2a0d08b] bob modify 2

$ git push
Counting objects: 10, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 614 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (6/6), done.
To /home/gittest/myproject.git
   fd68bba..2a0d08b  master -> master
  
... 成功 ...
</code>

上記のAliceとBobのやり取りは、オリジナルのbareリポジトリー(myproject.git)に次のように記録されます。
<code>
$ git log
commit 2a0d08b5d62b156d7ee7c481869d62efd76f3bed
    bob modify 2

commit 5dee8d1052e7d082649c7fcfe77846c1f2ad62ce
    bob modify

commit fd68bbaf65e78633a4a82403ea00da0642a4d8fe
    alice modify

</code>

===== リモート共有リポジトリー =====
上記の例では、ローカルなマシン上のmyproject.gitディレクトリを、AliceとBobで共有するシナリオを見てきました。
このmyproject.gitのようなbareリポジトリーを、ネットワーク上に公開する事で、共有リポジトリー化することができます。

ネットワーク上に公開する方法は、SSHを使用する、gitのネイティブな通信機能を使う、HTTP/HTTPS等を通じて配布する、等のバリエーションがあります。読み書きの両方が可能であり、かつ、セキュリティ的な側面をカバーするには、SSHによるセットアップが容易です。

==== 共通アカウント(git)を使う方法 ====
メンバーのUNIXアカウントは、サーバー上に作成せず、1つの共通アカウント(git)を使う方法です。共通のアカウントは、メンバーのSSH公開鍵を信頼します。メンバーのアカウントを作成する必要はありませんが、複数のメンバーが共通アカウントを用いたアクセスを許さなければなりません。

AliceとBobが共に、SSHでアクセス可能なアカウント(git)をサーバー(server)に作成し、ここにbareリポジトリーを作成します。git@serverはAliceとBobは共に読み書きが可能となるので、信頼のおけるプロジェクトのメンバーである事が前提です。

<code>
server# useradd git
server# su - git

... 初期化 ...
server$ git config --global user.name 'kdc'
server$ git config --global user.email 'kdc@knowd.co.jp'

server$ mkdir shareproject
server$ cd shareproject
server$ echo "Hello World." > readme.txt

server$ git init
server$ git add .
server$ git commit -m 'project starting point'
[master (root-commit) 82f40c1] project starting point
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 readme.txt

server$ cd ..

server$ git clone --bare shareproject shareproject.git
Cloning into bare repository shareproject.git...
done.

</code>


aliceとbobの、SSH公開鍵をgit@serverに登録します。SSHのキーは次のように作成されます。
<code>
[alice@pc]$ ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/home/alice/.ssh/id_rsa): 
Created directory '/home/alice/.ssh'.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/alice/.ssh/id_rsa.
Your public key has been saved in /home/alice/.ssh/id_rsa.pub.
The key fingerprint is:
09:a8:00:0c:06:07:24:74:a8:80:55:57:81:f3:3e:bb alice@lx13.example.com
The key's randomart image is:
+--[ RSA 2048]----+
|&*+o. .oo.       |
|*+.  oo          |
|+   . .o         |
|.. .   ...       |
|  .    .S        |
|        o        |
|         o       |
|        .        |
|        E.       |
+-----------------+

... aliceの公開鍵 ...
[alice@pc]$ cat .ssh/$ cat .ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2E... alice@alice-pc.example.com

</code>

二人のアクセスを認めるために、git@serverの~/.ssh/authorized_keysに、それぞれの公開鍵を追加します。

server上の/home/git/.ssh/authorized_keys
<code>
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQE... alice@alice-pc.example.com
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQE... bob@bob-pc.example.com
</code>


alice, bobがsshで、git@serverにアクセス可能である事を確認します。
<code>
[alice@pc]$ ssh git@server
...
Are you sure you want to continue connecting (yes/no)? yes
Enter passphrase for key '/home/alice/.ssh/id_rsa': 

[git@server]$ 
</code>

git@serverより、shareproject.gitをcloneします。
<code>
[alice@pc]$ git clone ssh://git@server/home/git/shareproject.git
Initialized empty Git repository in /home/alice/shareproject/.git/
Enter passphrase for key '/home/alice/.ssh/id_rsa': 

remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (3/3), done.

[alice@pc]$ cd shareproject
[alice@pc]$ ls
readme.txt

[alice@pc]$ git var -l
...
remote.origin.url=ssh://git@server/home/git/shareproject.git
...

[alice@pc]$ git log
$ git log
commit 82f40c1393aadb5c36f5e52aac0ea8908ffb33e1
Author: kdc <kdc@knowd.co.jp>
Date:   Sun Oct 23 23:18:36 2011 +0900

    project starting point

</code>

alice, bob 共に、ネットワークを通じて共通のリポジトリーを持つことができました。
<code>
... alice ...
[alice@pc]$ cd shareproject
[alice@pc]$ echo "alice join" >> readme.txt
[alice@pc]$ git add .
[alice@pc]$ git commit -m 'alice joined'

[alice@pc]$ git push
Enter passphrase for key '/home/alice/.ssh/id_rsa': 
Counting objects: 5, done.
Writing objects: 100% (3/3), 265 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://git@ns.knowd.co.jp:222/home/git/shareproject.git/
   82f40c1..29b7014  master -> master



... git@server ...
[git@server]$ cd shareproject.git
[git@server]$ git log
commit 29b70145d664e6fe064dd71ef23bf9f0e435bd92
    alice joined

commit 82f40c1393aadb5c36f5e52aac0ea8908ffb33e1
    project starting point


... bob ...
[bob@pc]$ cd shareproject/
[bob@pc]$ git pull
Enter passphrase for key '/home/bob/.ssh/id_rsa': 
Updating 82f40c1..29b7014
Fast-forward
 readme.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

[bob@pc]$ cat readme.txt 
Hello World.
alice join.

[bob@pc]$ git log
commit 29b70145d664e6fe064dd71ef23bf9f0e435bd92
    alice joined

commit 82f40c1393aadb5c36f5e52aac0ea8908ffb33e1
    project starting point

[bob@pc]$ echo "bob join" >> readme.txt
[bob@pc]$ echo "bob join" >> readme.txt 
[bob@pc]$ git add .
[bob@pc]$ git commit -m 'bob joined'
[master 61ac1e4] bob joined
 1 files changed, 1 insertions(+), 0 deletions(-)

[bob@pc]$ git push
Enter passphrase for key '/home/bob/.ssh/id_rsa': 
Counting objects: 5, done.
Writing objects: 100% (3/3), 265 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://git@ns.knowd.co.jp:222/home/git/shareproject.git/
   29b7014..61ac1e4  master -> master
   

... git@server ...
[git@server]$ git log
commit 61ac1e4cffe7dc09489814224144fb9375654649
Author: bob <bob@example.com>
Date:   Mon Oct 24 00:24:43 2011 +0900

    bob joined

commit 29b70145d664e6fe064dd71ef23bf9f0e435bd92
Author: alice <alice@lx13.example.com>
Date:   Mon Oct 24 00:13:40 2011 +0900

    alice joined

commit 82f40c1393aadb5c36f5e52aac0ea8908ffb33e1
Author: kdc <kdc@knowd.co.jp>
Date:   Sun Oct 23 23:18:36 2011 +0900

    project starting point

</code>

==== グループを用いた設定 ====
各メンバーのUNIXアカウントがサーバー上にある場合、それぞれのメンバーをグループ管理し、そのグループが読み書きできる共通のディレクトリーにリポジトリーを作成します。

<code>
[server]# groupadd developers
[server]# useradd -G developers alice
[server]# useradd -G developers bob

[server]# mkdir /var/repo
[server]# chmod 2775 /var/repo
[server]# su - alice

[alice@server]$ cd /var/repo
[alice@server]$ mkdir develop.git
[alice@server]$ cd develop.git
[alice@server]$ git init --bare --shared
Initialized empty shared Git repository in /var/repo/develop.git/
</code>

以上で、server上に、developerグループに所属するユーザーがアクセス可能なリポジトリーが設定されました。
 
SSHでserverにアクセス可能であれば、以下のようにリポジトリーをクローンできます。

<code>
[alice@pc]$ git clone ssh://server:222/var/repo/develop.git
Initialized empty Git repository in /home/alice/develop/.git/
Enter passphrase for key '/home/alice/.ssh/id_rsa': 
warning: You appear to have cloned an empty repository.

[alice@pc]$ cd develop/
[alice@pc]$ echo "I'm Alice" > greeting.txt
[alice@pc]$ git add .
[alice@pc]$ git commit -a -m 'first greeting'

[alice@pc]$ git push -u origin master
Enter passphrase for key '/home/alice/.ssh/id_rsa': 
Counting objects: 3, done.
Writing objects: 100% (3/3), 222 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://server/var/repo/develop.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.

</code>
server側のbareリポジトリーに記録された事を確認します。
<code>
[alice@server]$ cd /var/repo/develop.git
[alice@server]$ git log
commit 86e89c63a30b282ba9de7f1e0403ca526ce37361
Author: alice <alice@example.com>
Date:   Mon Oct 24 04:31:53 2011 +0900

    first greeting

</code>

bobが情報をpull/pushできる事を確認します。
<code>
[bob@pc]$ git clone ssh://server2/var/repo/develop.git
Initialized empty Git repository in /home/bob/develop/.git/
Enter passphrase for key '/home/bob/.ssh/id_rsa': 
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (3/3), done.

[bob@pc]$ ls
develop
[bob@pc]$ cd develop/
[bob@pc]$ ls
greeting.txt

[bob@pc]$ echo "I'm Bob" >> greeting.txt 

[bob@pc]$ cat greeting.txt 
I'm Alice
I'm Bob

[bob@pc]$ git commit -m 'bob, first greeting'
[master 8058835] bob, first greeting
 1 files changed, 1 insertions(+), 0 deletions(-)
 
[bob@pc]$ git push
Enter passphrase for key '/home/bob/.ssh/id_rsa': 
Counting objects: 5, done.
Writing objects: 100% (3/3), 259 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://server/var/repo/develop.git
   86e89c6..8058835  master -> master

</code>

serverでのログを確認します。
<code>
[alice@server]$ git log
commit 805883544d9215bbfcc5b5613ec14528c03e3051
Author: bob <bob@example.com>
Date:   Mon Oct 24 04:42:13 2011 +0900

    bob, first greeting

commit 86e89c63a30b282ba9de7f1e0403ca526ce37361
Author: alice <alice@example.com>
Date:   Mon Oct 24 04:31:53 2011 +0900

    first greeting
</code>

===== 他のリポジトリーとのpush/pull =====
他に共有リポジトリーがセットアップされていれば、現在保持しているリポジトリーを別の共有リポジトリーにpushすることができます。

例えば、bobは、github.comという共有リポジトリーにアクセスできると仮定します。

これまでの例では、git@server が、オリジナルとなっており、bobはそこから shareproject をクローンしました。デフォルトでは、pushする先はオリジナルのgit@serverとなっていますが、これがpushできる唯一のリモートリポジトリーではありません。
デフォルトのpush/pullのリモートURLは、originとなっており、これは、remote.origin.urlに定義されています。

<code>
[bob@pc]$ git var -l
...
remote.origin.url=ssh://git@server/home/git/shareproject.git/
...
</code>

新たに、リモートリポジトリーを追加するには、remote add コマンドで行います。
<code>
[bob@pc]$ cd shareproject
[bob@pc]$ git remote add github git@github.com:bob/shareproject.git

[bob@pc]$ git var -l
...
remote.origin.url=ssh://git@server/home/git/shareproject.git/
remote.github.url=git@github.com:bob/shareproject.git
...
</code>
新たに、githubという定義が加えられます。
github.comのshareproject.gitには、bareリポジトリーを用意しておきます。
push/pullが可能です。

<code>
$ git push github master

Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 691 bytes, done.
Total 9 (delta 0), reused 9 (delta 0)
To git@github.com:bob/shareproject.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from github.
</code>

===== アップストリーム・リポジトリーのセット(--set-upstream) =====
デフォルトでは、クローン元のリポジトリーがoriginとして定義され、デフォルトとなっていますが、複数のサイトとpush/pullを行うと、デフォルトを切り替えたくなる場合があります。

masterブランチに対するデフォルトのリモートリポジトリーは、git変数のbranch.master.remoteに定義されています。この変数は、git configコマンドで変更することもできますし、pushする際に、-u (%%--set-upstream%%)オプションを指定すると、そのサイトがpush/pullする際のデフォルトのリポジトリーとなります。

====== github ======
{{ 04-git-im.png?400}}
github.comでは、gitリポジトリーのホスティングが提供されています。
@Todo
